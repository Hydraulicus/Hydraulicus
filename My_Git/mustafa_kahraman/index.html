<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="http://d3js.org/d3.v3.min.js" language="JavaScript"></script>
    <!--<script src="js/liquidFillGauge.js" language="JavaScript"></script>-->
    <style>
					.liquidFillGaugeText { font-family: Helvetica; font-weight: bold; }

                    input[type=range] {
                        -webkit-appearance: none;
                        margin: 18px 0;
                        width: 100%;
                    }
                    input[type=range]:focus {
                        outline: none;
                    }
                    input[type=range]::-webkit-slider-runnable-track {
                        width: 100%;
                        height: 8.4px;
                        cursor: pointer;
                        animate: 0.2s;
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                        background: #3071a9;
                        border-radius: 1.3px;
                        border: 0.2px solid #010101;
                    }
                    input[type=range]::-webkit-slider-thumb {
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                        border: 1px solid #000000;
                        height: 36px;
                        width: 16px;
                        border-radius: 3px;
                        background: #ffffff;
                        cursor: pointer;
                        -webkit-appearance: none;
                        margin-top: -14px;
                    }
                    input[type=range]:focus::-webkit-slider-runnable-track {
                        background: #367ebd;
                    }
                    input[type=range]::-moz-range-track {
                        width: 100%;
                        height: 8.4px;
                        cursor: pointer;
                        animate: 0.2s;
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                        background: #3071a9;
                        border-radius: 1.3px;
                        border: 0.2px solid #010101;
                    }
                    input[type=range]::-moz-range-thumb {
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                        border: 1px solid #000000;
                        height: 36px;
                        width: 16px;
                        border-radius: 3px;
                        background: #ffffff;
                        cursor: pointer;
                    }
                    input[type=range]::-ms-track {
                        width: 100%;
                        height: 8.4px;
                        cursor: pointer;
                        animate: 0.2s;
                        background: transparent;
                        border-color: transparent;
                        border-width: 16px 0;
                        color: transparent;
                    }
                    input[type=range]::-ms-fill-lower {
                        background: #2a6495;
                        border: 0.2px solid #010101;
                        border-radius: 2.6px;
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                    }
                    input[type=range]::-ms-fill-upper {
                        background: #3071a9;
                        border: 0.2px solid #010101;
                        border-radius: 2.6px;
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                    }
                    input[type=range]::-ms-thumb {
                        box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
                        border: 1px solid #000000;
                        height: 36px;
                        width: 16px;
                        border-radius: 3px;
                        background: #ffffff;
                        cursor: pointer;
                    }
                    input[type=range]:focus::-ms-fill-lower {
                        background: #3071a9;
                    }
                    input[type=range]:focus::-ms-fill-upper {
                        background: #367ebd;
                    }

				.Row1
				{
					width: 30%;
				}	
					.circle{
						width: 50%;
					}		
					.circle-1{
						display: inline-block;
				position: relative;
				width: 30%;
				vertical-align: top;
				overflow: hidden;
				/*background-color: #eee;*/
				background-color: #e2e2e2;
					}

					.Column1
					{
							display: inline-block;
							position: relative;
							width: 30%;
							vertical-align: top;
							overflow: hidden;
							background-color: #fff;
					}
	</style>
</head>
<body>


	<div class="Row1">
			<div class="Column1">
                <p>Enter protein: </p> <input type="range" min="0" max="100" value="13" step="5"  >
                <svg id="fillgauge1"  width="100%" height="100%" viewBox="0 0 120 120"  preserveAspectRatio="xMinYMin meet" onclick=""></svg>
            </div>
			<div class="Column1">
                <p>Enter carb: </p> <input type="range" min="0" max="100" value="38" step="5"  >
                <svg id="fillgauge2" width="100%" height="100%"  viewBox="0 0 120 120"   onclick=""></svg>
            </div>
        <div class="Column1">
            <p>Enter fat: </p> <input type="range" min="0" max="100" value="50" step="5"  >
            <svg id="fillgauge3"   width="100%" height="100%" viewBox="0 0 120 120" onclick=""></svg>
            </div>
	</div>


	<div class="circle">
		<div class="circle-1"> <svg viewBox="0 0 100 100">
		<circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
			</svg>
	</div>
	<div class="circle-1"> <svg viewBox="0 0 100 100">
		<circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
			</svg>
	</div>
	<div class="circle-1"> <svg viewBox="0 0 100 100">
		<circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
			</svg></div>
	</div>

<script language="JavaScript">
    var inputProtein = document.getElementsByTagName('input')[0];
    var inputCarb = document.getElementsByTagName('input')[1];
    var inputFat = document.getElementsByTagName('input')[2];

    inputProtein.onchange = function() {  gauge1.update(this.value);   };
    inputCarb.onchange = function() {  gauge2.update(this.value);   };
    inputFat.onchange = function() {  gauge3.update(this.value);   };
</script>




<script language="JavaScript">
 var config_default = liquidFillGaugeDefaultSettings();
config_default.circleThickness = 0.2;
config_default.textVertPosition = 0.3;
config_default.waveAnimateTime = 5000;
config_default.displayPercent = false;
config_default.maxValue = 500;

var config_info = liquidFillGaugeDefaultSettings();
var config_warning = liquidFillGaugeDefaultSettings();
var config_danger = liquidFillGaugeDefaultSettings();

config_info.circleColor = "#51a821"
config_info.textColor = "#1E5200"
config_info.waveTextColor = "#51a821"
config_info.waveColor = "#91EE5F"

config_warning.circleColor = "#f7bf1e"
config_warning.textColor = "#765a04"
config_warning.waveTextColor = "#f7bf1e"
config_warning.waveColor = "#ffe9a8"
config_warning.warningThreshold = .4;
config_warning.waveCount = 2;
config_warning.waveRiseTime = 40;
config_warning.waveAnimateTime = 6000;

config_danger.circleColor = "#f7321e"
config_danger.textColor = "#4f0a03"
config_danger.waveTextColor = "#f7321e"
config_danger.waveColor = "#fedbd8"
config_danger.dangerThreshold = .2;
config_danger.waveCount = 2;
config_danger.waveRiseTime = 25;
config_danger.waveAnimateTime = 1400;
config_danger.waveHeight = 0.15;

// fetch raw values from database 
var protein_gram = 10;
var fat_gram = 20;
var carb_gram = 30;
var total_calories = 320;

var calories_from_carb = carb_gram*4;
var calories_from_fat = fat_gram*8;
var calories_from_protein = protein_gram*4;

var protein_percentage = Math.round((calories_from_protein/total_calories)*100);
var carb_percentage = Math.round((calories_from_carb/total_calories)*100);
var fat_percentage = Math.round((calories_from_fat/total_calories)*100);

var gauge1 = loadLiquidFillGauge("fillgauge1", protein_percentage, config_danger, protein_gram, " protein", protein_percentage);
var gauge2 = loadLiquidFillGauge("fillgauge2", carb_percentage, config_warning, carb_gram, " carb", carb_percentage);
var gauge3 = loadLiquidFillGauge("fillgauge3", fat_percentage, config_info, fat_gram, " fat", fat_percentage);


/*!
 * @license Open source under BSD 2-clause (http://choosealicense.com/licenses/bsd-2-clause/)
 * Copyright (c) 2015, Curtis Bratton
 * All rights reserved.
 *
 * Liquid Fill Gauge v1.1
 */
function liquidFillGaugeDefaultSettings() {
  return {
    minValue: 0, // The gauge minimum value.
    maxValue: 100, // The gauge maximum value.
    circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
    circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
    circleColor: "#178BCA", // The color of the outer circle.
    waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
    waveCount: 1, // The number of full waves per width of the wave circle.
    waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
    waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
    waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
    waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
    waveAnimate: true, // Controls if the wave scrolls or is static.
    waveColor: "#178BCA", // The color of the fill wave.
    waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
    textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
		textVertPosition1: 0.3,
    textSize: 0.4, // The relative height of the text to display in the wave circle. 1 = 50%
		 textSize_line2: 0.3, // The relative height of the text to display in the wave circle. 1 = 50%
		
    valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
    displayPercent: false, // If true, a % symbol is displayed after the value.
    textColor: "#045681", // The color of the value text when the wave does not overlap it.
    waveTextColor: "#A4DBf8" // The color of the value text when the wave overlaps it.
  };
}

function loadLiquidFillGauge(elementId, value, config, macro, macro_name, macro_percentage) {
  if (config == null) config = liquidFillGaugeDefaultSettings();	
	
  var gauge = d3.select("#" + elementId);
  var radius = Math.min(parseInt(gauge.style("width")), parseInt(gauge.style("height"))) / 2;
  var locationX = parseInt(gauge.style("width")) / 2 - radius;
  var locationY = parseInt(gauge.style("height")) / 2 - radius;
    var locationWidth = parseInt(gauge.style("width"));
    var locationHeight = parseInt(gauge.style("height"));
  var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;

  var waveHeightScale;
  if (config.waveHeightScaling) {
    waveHeightScale = d3.scale.linear()
      .range([0, config.waveHeight, 0])
      .domain([0, 50, 100]);
  } else {
    waveHeightScale = d3.scale.linear()
      .range([config.waveHeight, config.waveHeight])
      .domain([0, 100]);
  }

  var textPixels = (config.textSize * radius / 2);
	var textPixels_line2 = (config.textSize_line2 * radius / 2);
  var textFinalValue = parseFloat(macro).toFixed(2);
  var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
  var percentText = config_default.displayPercent ? " gr" : "";
	var circleThickness = config.circleThickness * radius;
  var circleFillGap = config.circleFillGap * radius;
  var fillCircleMargin = circleThickness + circleFillGap;
  var fillCircleRadius = radius - fillCircleMargin;
  var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);

  var waveLength = fillCircleRadius * 2 / config.waveCount;
  var waveClipCount = 1 + config.waveCount;
  var waveClipWidth = waveLength * waveClipCount;

  // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
  var textRounder = function(value) {
    return Math.round(value);
  };
  if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
    textRounder = function(value) {
      return parseFloat(value).toFixed(1);
    };
  }
  if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
    textRounder = function(value) {
      return parseFloat(value).toFixed(2);
    };
  }

  // Data for building the clip wave area.
  var data = [];
  for (var i = 0; i <= 40 * waveClipCount; i++) {
    data.push({
      x: i / (40 * waveClipCount),
      y: (i / (40))
    });
  }

  // Scales for drawing the outer circle.
  var gaugeCircleX = d3.scale.linear().range([0, 2 * Math.PI]).domain([0, 1]);
  var gaugeCircleY = d3.scale.linear().range([0, radius]).domain([0, radius]);

  // Scales for controlling the size of the clipping path.
  var waveScaleX = d3.scale.linear().range([0, waveClipWidth]).domain([0, 1]);
  var waveScaleY = d3.scale.linear().range([0, waveHeight]).domain([0, 1]);

  // Scales for controlling the position of the clipping path.
  var waveRiseScale = d3.scale.linear()
    // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
    // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
    // circle at 100%.
    .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])
    .domain([0, 1]);
  var waveAnimateScale = d3.scale.linear()
    .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
    .domain([0, 1]);

  // Scale for controlling the position of the text within the gauge.
  var textRiseScaleY = d3.scale.linear()
    .range([fillCircleMargin + fillCircleRadius * 2, (fillCircleMargin + textPixels * 0.7)])
    .domain([0, 1]);

  // Center the gauge within the parent SVG.
  var gaugeGroup = gauge.append("g")
//    .attr('transform', 'translate(' + locationX + ',' + locationY + ')')
          ;
    gauge.attr('viewBox',`0 0 ${locationWidth} ${locationHeight}`);



  // Draw the outer circle.
  var gaugeCircleArc = d3.svg.arc()
    .startAngle(gaugeCircleX(0))
    .endAngle(gaugeCircleX(1))
    .outerRadius(gaugeCircleY(radius))
    .innerRadius(gaugeCircleY(radius - circleThickness));
  gaugeGroup.append("path")
    .attr("d", gaugeCircleArc)
    .style("fill", config.circleColor)
    .attr('transform', 'translate(' + radius + ',' + radius + ')');

  // Text where the wave does not overlap.
  var text1 = gaugeGroup.append("text")
    .text(textRounder(textStartValue) + percentText)
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels + "px")
    .style("fill", config.textColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

	
	 
	
  // The clipping wave area.
  var clipArea = d3.svg.area()
    .x(function(d) {
      return waveScaleX(d.x);
    })
    .y0(function(d) {
      return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));
    })
    .y1(function(d) {
      return (fillCircleRadius * 2 + waveHeight);
    });
  var waveGroup = gaugeGroup.append("defs")
    .append("clipPath")
    .attr("id", "clipWave" + elementId);
  var wave = waveGroup.append("path")
    .datum(data)
    .attr("d", clipArea)
    .attr("T", 0);

  // The inner circle with the clipping wave attached.
  var fillCircleGroup = gaugeGroup.append("g")
    .attr("clip-path", "url(#clipWave" + elementId + ")");
  fillCircleGroup.append("circle")
    .attr("cx", radius)
    .attr("cy", radius)
    .attr("r", fillCircleRadius)
    .style("fill", config.waveColor);

  // Text where the wave does overlap.
  var text2 = fillCircleGroup.append("text")
    .text(textRounder(textStartValue) + percentText)
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels + "px")
    .style("fill", config.waveTextColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

	var text3 = fillCircleGroup.append("text")
    .text(macro_percentage + "%")
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels_line2 + "px")
    .style("fill", config.textColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition1) + ')');

	var text3 = gaugeGroup.append("text")
    .text(macro_percentage + "%")
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels_line2 + "px")
    .style("fill", config.textColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition1) + ')');

	
	
  // Make the value count up.
  if (config.valueCountUp) {
    var textTween = function() {
      var i = d3.interpolate(this.textContent, textFinalValue);
      return function(t) {
        this.textContent = textRounder(i(t)) + percentText +  macro_name ;
     }
    };
    text1.transition()
      .duration(config.waveRiseTime)
      .tween("text", textTween);
    text2.transition()
      .duration(config.waveRiseTime)
      .tween("text", textTween);
  }

  // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
  var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
  if (config.waveRise) {
    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
      .transition()
      .duration(config.waveRiseTime)
      .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
      .each("start", function() {
        wave.attr('transform', 'translate(1,0)');
      }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
  } else {
    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
  }

  if (config.waveAnimate) animateWave();

  function animateWave() {
    wave.attr('transform', 'translate(' + waveAnimateScale(wave.attr('T')) + ',0)');
    wave.transition()
      .duration(config.waveAnimateTime * (1 - wave.attr('T')))
      .ease('linear')
      .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
      .attr('T', 1)
      .each('end', function() {
        wave.attr('T', 0);
        animateWave(config.waveAnimateTime);
      });
  }

  function GaugeUpdater() {
    this.update = function(value) {
      var newFinalValue = parseFloat(value).toFixed(2);
      var textRounderUpdater = function(value) {
        return Math.round(value);
      };
      if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
        textRounderUpdater = function(value) {
          return parseFloat(value).toFixed(1);
        };
      }
      if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
        textRounderUpdater = function(value) {
          return parseFloat(value).toFixed(2);
        };
      }

      var textTween = function() {
        var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));
        return function(t) {
          this.textContent = textRounderUpdater(i(t)) + percentText;
        }
      };

      text1.transition()
        .duration(config.waveRiseTime)
        .tween("text", textTween);
      text2.transition()
        .duration(config.waveRiseTime)
        .tween("text", textTween);

      var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
      var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
      var waveRiseScale = d3.scale.linear()
        // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
        // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
        // circle at 100%.
        .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])
        .domain([0, 1]);
      var newHeight = waveRiseScale(fillPercent);
      var waveScaleX = d3.scale.linear().range([0, waveClipWidth]).domain([0, 1]);
      var waveScaleY = d3.scale.linear().range([0, waveHeight]).domain([0, 1]);
      var newClipArea;
      if (config.waveHeightScaling) {
        newClipArea = d3.svg.area()
          .x(function(d) {
            return waveScaleX(d.x);
          })
          .y0(function(d) {
            return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));
          })
          .y1(function(d) {
            return (fillCircleRadius * 2 + waveHeight);
          });
      } else {
        newClipArea = clipArea;
      }

      var newWavePosition = config.waveAnimate ? waveAnimateScale(1) : 0;
      wave.transition()
        .duration(0)
        .transition()
        .duration(config.waveAnimate ? (config.waveAnimateTime * (1 - wave.attr('T'))) : (config.waveRiseTime))
        .ease('linear')
        .attr('d', newClipArea)
        .attr('transform', 'translate(' + newWavePosition + ',0)')
        .attr('T', '1')
        .each("end", function() {
          if (config.waveAnimate) {
            wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
            animateWave(config.waveAnimateTime);
          }
        });
      waveGroup.transition()
        .duration(config.waveRiseTime)
        .attr('transform', 'translate(' + waveGroupXPosition + ',' + newHeight + ')')
    }
  }

  return new GaugeUpdater();
}
</script>
</body>
</html>